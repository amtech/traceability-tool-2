/**
 * 
 */
package org.tools.doc.traceability.common;

import java.awt.Color;

import org.tools.doc.traceability.common.worksheet.CellBorderType;
import org.tools.doc.traceability.common.worksheet.HorizontalAlignmentType;

/**
 * Constants for the project.
 * 
 * @author Yann Leglise
 *
 */
public final class Constants {

    /**
     * Name of the log configuration file.
     */
    public static final String LOGGING_CONFIGURATION_FILENAME = "log4j2.xml";
    
    /**
     * Number of the column in the tables of input document where the
     * requirement name is to be searched. For the first column, use 1.
     */
    public static final int REQ_EXTRACTION_TABLE_COL_IDX = 1;

    /**
     * The width for the column for the requirements in the output file
     * generated by the Matrix Generator tool.
     */
    public static final int COVMAT_REQUIREMENT_COL_WIDTH_IN_OUTPUT_FILE = 40;

    /**
     * The width for the column for the test identifier in the output file
     * generated by the Matrix Generator tool.
     */
    public static final int COVMAT_TEST_ID_COL_IDX_IN_OUTPUT_FILE = 50;

    /**
     * The width for the column for the test name in the output file generated
     * by the Matrix Generator tool.
     */
    public static final int COVMAT_TEST_NAME_COL_IDX_IN_OUTPUT_FILE = 90;

    /**
     * The width for the column for the test origin details in the output file
     * generated by the Matrix Generator tool.
     */
    public static final int COVMAT_TEST_ORIGIN_DETAIL_COL_IDX_IN_OUTPUT_FILE = 50;

    /**
     * The width for the column for the requirements in the not covered
     * requirement sheet of the output file generated by the Matrix Generator
     * tool.
     */
    public static final int COVMAT_NOT_COVERED_REQUIREMENT_COL_WIDTH_IN_OUTPUT_FILE = 40;

    /**
     * The width for the column for the justification in the not covered
     * requirement sheet of the output file generated by the Matrix Generator
     * tool.
     */
    public static final int COVMAT_JUSTIFICATION_COL_WIDTH_IN_OUTPUT_FILE = 90;

    /**
     * The index of the column for the Test Set name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_SET_NAME_COL_IDX = 0;

    /**
     * The width of the column for the Test Set name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_SET_NAME_COL_WIDTH = 15;

    /**
     * The label of the column for the Test Set name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final String VTPUDATER_TEST_SET_NAME_COL_LABEL = "Test set";

    /**
     * The index of the column for the Test Case Identifier in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_CASE_IDENTIFIER_COL_IDX = 1;

    /**
     * The width of the column for the Test Case Identifier in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_CASE_IDENTIFIER_COL_WIDTH = 15;

    /**
     * The label of the column for the Test Case Identifier in the target VTP
     * file updated by the VTP Updater.
     */
    public static final String VTPUDATER_TEST_CASE_IDENTIFIER_COL_LABEL = "Test case ID";

    /**
     * The index of the column for the Test Case Name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_CASE_NAME_COL_IDX = 2;

    /**
     * The width of the column for the Test Case Name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_TEST_CASE_NAME_COL_WIDTH = 25;

    /**
     * The label of the column for the Test Case Name in the target VTP file
     * updated by the VTP Updater.
     */
    public static final String VTPUDATER_TEST_CASE_NAME_COL_LABEL = "Test case name";

    /**
     * The index of the column for the Procedure description in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_PROCEDURE_COL_IDX = 3;

    /**
     * The width of the column for the Procedure description in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_PROCEDURE_COL_WIDTH = 60;

    /**
     * The label of the column for the Procedure in the target VTP file updated
     * by the VTP Updater.
     */
    public static final String VTPUDATER_PROCEDURE_COL_LABEL = "Procedure description";

    /**
     * The index of the column for the Expected Result in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_EXPECTED_RESULT_COL_IDX = 4;

    /**
     * The width of the column for the Expected Result in the target VTP file
     * updated by the VTP Updater.
     */
    public static final int VTPUDATER_EXPECTED_RESULT_COL_WIDTH = 60;

    /**
     * The label of the column for the Expected Result in the target VTP file
     * updated by the VTP Updater.
     */
    public static final String VTPUDATER_EXPECTED_RESULT_COL_LABEL = "Expected results";

    /**
     * The index of the column for the Covered Requirements in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_COVERED_REQUIREMENTS_COL_IDX = 5;

    /**
     * The width of the column for the Covered Requirements in the target VTP
     * file updated by the VTP Updater.
     */
    public static final int VTPUDATER_COVERED_REQUIREMENTS_COL_WIDTH = 40;

    /**
     * The string of the column for the Covered Requirements in the target VTP
     * file updated by the VTP Updater.
     */
    public static final String VTPUDATER_COVERED_REQUIREMENTS_COL_LABEL = "Covered requirements";

    /**
     * The separator used between the different covered requirements in the
     * output VTP file generated by the VTP Updater.
     */
    public static final String VTPUPDATER_COVERED_REQUIREMENTS_SEPARATOR = "\n";

    /**
     * Regular expression for finding requirement references in "Expected
     * Result" columns of manual test VTP.
     * <p>
     * A requirement is a string starting with "SD" and placed between squared
     * brackets.
     * </p>
     */
    public static final String EXPECTED_RESULT_COLUMN_WITH_REQUIREMENTS_REGEXP = "\\[([^\\[]*)\\]";

    /**
     * The factor used to convert a number of characters for a cell width to the
     * unit expected by setColumnWidth for a sheet (i.e. 256th of character
     * width).
     */
    public static final int CHARCTER_WIDTH_FACTOR = 256;

    /**
     * The height of the font, in points, in workbook.
     */
    public static final short WORKBOOK_FONT_HEIGHT = 12;

    /**
     * Whether the font is bold or not in normal workbook cell.
     */
    public static final boolean WORKBOOK_IS_DATA_CELL_FORMAT_BOLD = false;

    /**
     * Whether the font is bold or not in header workbook cell.
     */
    public static final boolean WORKBOOK_IS_HEADER_CELL_FORMAT_BOLD = true;

    /**
     * The normal font color in workbooks.
     */
    public static final Color WORKBOOK_NORMAL_TEXT_COLOR = new Color(0, 0, 0);

    /**
     * The header font color in workbooks.
     */
    public static final Color WORKBOOK_HEADER_TEXT_COLOR = new Color(255, 255, 255);

    /**
     * The normal color of the cell background in workbooks.
     */
    public static final Color WORKBOOK_CELL_BACKGROUND_COLOR = new Color(255, 255, 255);

    /**
     * The color for the cell background in workbooks for headers.
     */
    public static final Color WORKBOOK_HEADER_CELL_BACKGROUND_COLOR = new Color(0, 112, 192);

    /**
     * The color for the cell background in workbooks for missing requirements.
     */
    public static final Color WORKBOOK_MISSING_REQUIREMENT_CELL_BACKGROUND_COLOR = new Color(255, 0, 0);

    /**
     * The color for the cell text in workbooks for missing requirements.
     */
    public static final Color WORKBOOK_MISSING_REQUIREMENT_CELL_TEXT_COLOR = new Color(255, 255, 255);

    /**
     * The text horizontal alignment in the header cell.
     */
    public static final HorizontalAlignmentType WORKBOOK_HEADER_CELL_HORIZONTAL_ALIGNMENT = HorizontalAlignmentType.CENTERED;

    /**
     * The type of border to apply to the cells of workbooks.
     */
    public static final CellBorderType WORKBOOK_CELL_BORDER = CellBorderType.THIN;

    /**
     * The name of the sheet in VTP workbooks that must be updated by the manual
     * test extract from HP ALM.
     */
    public static final String VTP_UPDATING_FROM_ALM_TARGET_SHEET_NAME = "Test Plan";

    /**
     * The name of the sheet in VTP workbooks that is used for identifying the
     * versions (and that shall not be removed).
     */
    public static final String VTP_IDENTTIFIICATION_SHEET_NAME = "Identification";

    /**
     * The regular expression used to parse a list of covered requirements.
     * <p>
     * Those requirements are separated by spaces or comma, and each requirement
     * may be (or not) surrounded by square brackets.
     * </p>
     * <p>
     * If it matches, then the first requirement is in group 1, and the
     * remaining part to search again for further requirement is in group 3.
     * </p>
     */
    public static final String COVERED_REQUIREMENT_LIST_REGEXP = "\\s*\\[?([A-Z0-9][A-Z0-9_-]*)\\]?\\s*(,?(.*))?";

    /**
     * The regular expression used to spot the Gherkin <b>Then</b> or <b>And</b>
     * steps that reference SD requirements.
     * <p>
     * The label of the step shall start with <tt>Reference SD </tt> (we allow
     * more spaces or the presence of <tt>:</tt> after), followed by the
     * requirement list and separated either by spaces or comma.
     * </p>
     * <p>
     * The fact that the list of requirements may be surrounded by double quotes
     * is handled in the program by removing them from the captured group.
     * </p>
     * <p>
     * If the regular expression matches, then the list of requirements is
     * captured in group 1.
     * </p>
     */
    public static final String GHERKIN_STEP_REQ_SD_REGEXP = "\\s*Reference \\s*SD\\s*:?\\s*(.*)\\s*";

    /**
     * The regular expression used to find requirements in a Gherkin <b>Then</b>
     * or <b>And</b> step that references SD requirements.
     * <p>
     * Those requirements are separated by a comma, and each requirement may be
     * (or not) surrounded by square brackets.
     * </p>
     * <p>
     * If it matches, then the first requirement is in group 1, and the
     * remaining part to search again for further requirement is in group 3.
     * </p>
     */
    public static final String GHERKIN_STEP_REQ_SD_REQ_REGEXP = COVERED_REQUIREMENT_LIST_REGEXP;

}
